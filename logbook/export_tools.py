from reportlab.pdfgen import canvas
from pyPdf import PdfFileWriter, PdfFileReader
import StringIO
from reportlab.lib.pagesizes import letter
import os
import random
import datetime
from django.http import Http404

PERMIT_NUM_FIELD = 'obs_nm' 


def get_usgs_quad(minlng, minlat, maxlng, maxlat):
    from django.contrib.gis.gdal.datasource import DataSource

    shp_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 
                        "quads", 'quadgrid_4326.shp')
    ds = DataSource(shp_path)
    layer = ds[0]

    if maxlng <= minlng:
        maxlng = minlng + 0.0001
    if maxlat <= minlat:
        maxlat = minlat + 0.0001

    layer.spatial_filter = (minlng, minlat, maxlng, maxlat)
    if len(layer) == 0:
        return ""
    else:
        return ', '.join([feat.get('Name') for feat in layer])


def extend_meta_profile(meta, user):
    profile = user.get_profile()
    uname = profile.name
    if uname == '':
        uname = user.get_username()
    meta['user']  = uname
    meta['agency'] = profile.organization
    meta['addr1'] = profile.address
    meta['addr2'] = profile.city  # TODO profile needs state, zip
    meta['today'] = datetime.datetime.now().strftime("%Y-%m-%d")
    return meta


def generate_pdf(id_string, user, permit_nums):
    from odk_viewer.models import ParsedInstance

    all_instances = ParsedInstance.objects.filter(instance__user=user,
                                        instance__xform__id_string=id_string,)

    # We should probably use the ORM filter for better performance but
    # I havent yet figured out how to query mongodb via ORM args
    pis = [x for x in all_instances 
             if x.to_dict().has_key(PERMIT_NUM_FIELD) and 
                x.to_dict()[PERMIT_NUM_FIELD] in permit_nums]

    if len(pis) == 0:
        raise Http404

    # TODO lots of mock data, needs to be derived from DB
    obs_data = [ 
        {
          'permit_num': pi.to_dict()[PERMIT_NUM_FIELD],
          'species': random.choice(['King Salmon', 'Chum Salmon']),
          'date': pi.to_dict()['today'],
          'lat': pi.lat,
          'lng': pi.lng,
          'spawning': 2,
          'rearing': 3,
          'present': 4,
          'anadromous': True
        }
       for pi in pis
    ]

    meta = {
        'region': "Region 1",
        'awc_num': '1234',
        'awc_name': "Salt Creek", 
        'awc_name_type': random.choice(['USGS', 'local']),
        'nomination_type': random.choice(['addition', 'deletion', 'correction', 'backup']),
    }

    meta = extend_meta_profile(meta, user)

    # TODO loop through pis
    meta['quad'] = get_usgs_quad(minlng, minlat, maxlng, maxlat)

    comments = "AWC nomination form generated by aklogbook.ecotrust.org"

    # Create pdf
    packet = StringIO.StringIO()
    can = canvas.Canvas(packet)

    # render a new PDF with Reportlab
    can = canvas.Canvas(packet, pagesize=letter)
    can.setFont('Courier', 9)

    # render metadata
    hs = [696, 673, 650, 631]
    can.drawString(120, hs[0] , meta['region'])
    can.drawString(380, hs[0], meta['quad'])
    can.drawString(270, hs[1], meta['awc_num'])
    can.drawString(160, hs[2], meta['awc_name'])

    if meta['awc_name_type'] == 'USGS':
        can.drawString(363, hs[2]+3, u"\u2713")
    elif meta['awc_name_type'] == 'local':
        can.drawString(466, hs[2]+3, u"\u2713")

    if meta['nomination_type'] == 'addition':
        can.drawString(59, hs[3], u"\u2713")
    elif meta['nomination_type'] == 'deletion':
        can.drawString(135, hs[3], u"\u2713")
    elif meta['nomination_type'] == 'correction':
        can.drawString(220, hs[3], u"\u2713")
    elif meta['nomination_type'] == 'backup':
        can.drawString(291, hs[3], u"\u2713")

    can.drawString(220, 190, meta['user'])
    can.drawString(220, 160, meta['agency'])
    can.drawString(220, 145, meta['addr1'])
    can.drawString(220, 130, meta['addr2'])
    can.drawString(450, 175, meta['today'])

    can.drawString(40, 280, comments)

    # render observational data
    for i, sd in enumerate(obs_data):
        height = 422 - 15*i
        can.drawString(40, height, sd['species'])
        can.drawString(150, height, sd['date'])
        can.drawString(295, height, str(sd['spawning']))
        can.drawString(360, height, str(sd['rearing']))
        can.drawString(440, height, str(sd['present']))
        if sd['anadromous']:
            can.drawString(502, height, u"\u2713")
    can.save()

    #move to the beginning of the StringIO buffer
    packet.seek(0)
    new_pdf = PdfFileReader(packet)

    # read your existing PDF
    orig = os.path.join(os.path.dirname(os.path.abspath(__file__)), 
                        "original.pdf")
    existing_pdf = PdfFileReader(file(orig, "rb"))
    output = PdfFileWriter()
    # add the "watermark" (which is the new pdf) on the existing page
    page = existing_pdf.getPage(0)
    page.mergePage(new_pdf.getPage(0))
    output.addPage(page)

    # finally, return output
    outputStream = StringIO.StringIO()
    output.write(outputStream)

    final = outputStream.getvalue()
    outputStream.close()
    return final


def generate_frp_xls(id_string, user, permit_nums):
    from odk_viewer.models import ParsedInstance
    import xlrd
    from xlutils.copy import copy

    all_instances = ParsedInstance.objects.filter(instance__user=user,
                                        instance__xform__id_string=id_string,)

    # We should probably use the ORM filter for better performance but
    # I havent yet figured out how to query mongodb via ORM args
    pis = [x for x in all_instances 
             if x.to_dict().has_key(PERMIT_NUM_FIELD) and 
                x.to_dict()[PERMIT_NUM_FIELD] in permit_nums]

    if len(pis) == 0:
        raise Http404

    obs_data = [ 
        {
          'permit_num': pi.to_dict()[PERMIT_NUM_FIELD],
          'species': random.choice(['King Salmon', 'Chum Salmon']),
          'date': pi.to_dict()['today'],
          'lat': pi.lat,
          'lng': pi.lng,
          'spawning': 2,
          'rearing': 3,
          'present': 4,
          'anadromous': True
        }
       for pi in pis
    ]

    meta = {
        'region': "Region 1",
        'quad': "Sneak Peak",
        'awc_num': '1234',
        'awc_name': "Salt Creek", 
        'awc_name_type': random.choice(['USGS', 'local']),
        'nomination_type': random.choice(['addition', 'deletion', 'correction', 'backup']),
    }

    meta = extend_meta_profile(meta, user)

    # TODO loop thru pis to get min/max extent
    meta['quad'] = get_usgs_quad(minlng, minlat, maxlng, maxlat)

    content = StringIO.StringIO()

    # read your existing PDF
    file_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 
                        "frp_original.xls")
    orig_book = xlrd.open_workbook(file_path, formatting_info=True)
    wb = copy(orig_book)
    ws = wb.get_sheet(0)
    start_row_idx = 4

    # todo assert all have same permit num, probably through ORM filter
    ws.write(0, 0, "ADF&G permit no. %s" % obs_data[0]['permit_num'])

    for i, obs in enumerate(obs_data):
        ws.write(start_row_idx + i, 0, obs['permit_num'])
        ws.write(start_row_idx + i, 1, obs['lat'])
        ws.write(start_row_idx + i, 2, obs['lng'])
        ws.write(start_row_idx + i, 3, "WGS84")
        ws.write(start_row_idx + i, 4, "Mobile GPS")
        ws.write(start_row_idx + i, 5, "<name>")
        ws.write(start_row_idx + i, 6, meta['user'])
        
    wb.save(content)

    final = content.getvalue() 
    content.close()
    return final